# 16. Space-based Architecture Style

스페이스 기반 아키텍처(Space-based Architecture)는 대량의 동시 요청 처리를 위한 분산 시스템 설계 방식으로, 병목 지점을 줄이고 높은 확장성과 가용성을 확보하는 데 적합한 아키텍처 스타일

---

## 16.0 Traditional Web-based Topology

전통적인 웹 기반 토폴로지는 다음과 같은 계층으로 구성됨:

- **클라이언트** → **웹 서버** → **애플리케이션 서버** → **데이터베이스**
- 병목 지점은 주로 **데이터베이스**에 집중되며, 트래픽이 급증할 경우 확장성 한계에 부딪힐 수 있음

---

## 16.1 토폴로지
처리 장치 : 애플리케이션 코드를 포함하고 실행

가상화된 미들웨어 : 처리 장치를 관리하고 조정

데이터 펌프 : 업데이트된 데이터를 비동기적으로 데이터베이스로 전송

데이터 작성자 : 데이터 펌프에서 데이터베이스 업데이트를 수행

데이터 리더 : 데이터베이스에서 처리 장치로 데이터를 전달
![이미지](https://miro.medium.com/v2/resize:fit:1100/format:webp/1*56ioxFRAcUfpGFVqcJCwvA.png)

스페이스 기반 아키텍처는 전통적인 중앙 집중형 데이터베이스 모델 대신 분산 메모리 그리드(in-memory data grid)를 기반으로 구성

- 각 **Processing Unit (PU)** 은 독립적으로 작동하며, 내부에 애플리케이션 로직과 캐시, 메시징, 이벤트 처리 기능이 포함
- 필요에 따라 PU를 수평 확장할 수 있으며, 시스템은 부하에 따라 자동으로 조정됨


---

## 16.2 스타일 특성

-  **높은 확장성**: 처리 유닛을 수평 확장 가능
-  **고가용성**: 노드 장애 시 다른 유닛이 자동 복구
-  **데이터 로컬리티**: 데이터 접근이 빠름 (메모리 기반)
-  **복잡한 동기화/구성**: 일관성 유지 및 상태 동기화가 복잡함
-  **메모리 의존도**: 대규모 데이터는 메모리 제한 이슈 발생 가능

---

## Processing Unit

Processing Unit(PU)은 다음과 같은 구성 요소를 포함:

- **Member List**: 현재 클러스터에 참여 중인 다른 PU들의 정보를 보유. 이를 통해 인스턴스 간 상태 동기화 및 클러스터 인식 수행.

###  토론주제 1
**스페이스 기반 아키텍처에서 동일 이름의 캐시를 가진 프로세싱 유닛 인스턴스들이 서로를 인지하고 데이터 동기화를 수행할 수 있는 메커니즘은 무엇이며, 어떻게 동작할까요?**

- PU는 클러스터 관리자(예: ZooKeeper, Hazelcast, GigaSpaces 등)를 통해 **Member List**를 공유

---

## Virtualized Middleware

### Messaging Grid

- PU 간 메시지 송수신을 담당하는 비동기 메시징 계층
- 작업 분배, 상태 전파, 이벤트 전달 등에 활용

### Data Grid

####  Replicated Caching
- 모든 노드에 동일한 데이터를 유지
- 데이터 일관성은 높지만, 동기화 오버헤드가 큼

####  Distributed Caching
- 데이터를 여러 노드에 분산 저장 (sharding)
- 확장성은 좋지만, 특정 노드 실패 시 데이터 손실 위험

####  Near Cache
- 자주 참조되는 데이터만 로컬에 캐시
- 빠른 접근이 가능하지만, 일관성 유지가 어려움

###  토론주제 2
**스페이스 기반 아키텍처에서 캐시의 구성 방식에는 어떤 종류가 있으며, 각 방식의 특징과 차이점은 무엇일까요?**

| 구성 방식         | 특징                             | 장점                      | 단점                       |
|------------------|----------------------------------|---------------------------|----------------------------|
| Replicated Cache | 모든 노드가 동일 데이터 유지     | 높은 데이터 가용성        | 높은 동기화 비용           |
| Distributed Cache| 데이터를 분산 저장                | 높은 확장성               | 일관성 관리 필요           |
| Near Cache       | 자주 사용하는 데이터만 로컬 유지 | 빠른 응답속도             | 데이터 불일치 가능성 있음  |

---

## Virtualized Middleware - Processing Grid

- **작업 분산 처리 담당**
- 사용자의 요청 또는 배치 작업을 여러 PU에 병렬 분산
- 부하 분산 및 고속 처리 가능

---

## Data Pumps

- 외부 시스템(DB, Kafka 등)에서 데이터를 가져와 PU로 전달하는 컴포넌트
- 실시간 스트리밍 또는 배치 처리 모두 지원

---

## Domain-based Data Writer

- 도메인 로직에 기반해 데이터를 저장
- 예: 주문 처리 로직에 따라 DB에 저장할지, 메시지 큐에 보낼지 결정

## Dedicated Data Writers

- 특정 데이터만 담당하는 저장기
- 예: 로그 전용 Writer, 사용자 세션 전용 Writer

## Data Readers

- 외부에서 PU 내부 데이터를 조회하거나, 쿼리하는 구성요소
- 예: REST API, 그래프QL 등과 연동

---

##  토론주제 3
**스페이스 기반 아키텍처 스타일의 아키텍처 특성을 평가해봅시다. 어떤 특성이 좋고 어떤 특성은 좋지 않을까요?**

| 항목 | 긍정적 특성 | 부정적 특성 |
|------|-------------|-------------|
| 확장성 | PU를 수평 확장 가능 | 초기 구성 복잡 |
| 성능 | 메모리 기반 고속 처리 | 메모리 용량 의존 |
| 가용성 | PU 장애 시 자동 복


구현 스택 예시

| 구성 요소                      | 구현 기술 예시                                 |
| -------------------------- | ---------------------------------------- |
| **Processing Unit**        | Java(Spring Boot), Kotlin, Node.js 등     |
| **Data Grid**              | Hazelcast, Apache Ignite, GigaSpaces XAP |
| **Messaging Grid**         | Apache Kafka, RabbitMQ, JMS              |
| **Virtualized Middleware** | Kubernetes, Docker, Spring Cloud         |
| **Persistent Storage**     | PostgreSQL, MongoDB 등                    |
| **Monitoring**             | Prometheus + Grafana, ELK Stack          |

